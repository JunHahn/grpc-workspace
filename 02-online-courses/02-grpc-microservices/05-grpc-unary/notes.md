# Session 05: [Hands-On] gRPC Project Overview & Setup

---

## 18. What's an Unary API

* Unary RPC calls are basic Request / Response that everyone is familar with
* The client will send **one** message to the server and will receive **one** response from the server
* Unary RPC calls will be the most common for your APIs
  * Unary calls are very well suited when your data is small
  * Start with Unary when writing APIs and use streaming API if performance is an issue

```note
              Unary API
------------             ------------
|          | ----------> |          |
|  Client  |             |  Server  |
|          | <---------- |          |
------------             ------------
```

* In gRPC, Unary Calls are defined using Protocol Buffers
* For each RPC call, we have to define a "Request" message and a "Response" message

```proto
message GreetRequest {
  Greeting greeting = 1;
}

message GreetResponse {
  string result = 1;
}

service GreetService {
  // Unary
  rpc Greet(GreetRequest) returns (GreetResponse) {};
}
```

---

## 19. Greet API Definition

### 19.1 Hands On - Greet API Definition

* **Hands On**: define a Unary "Greet" API
* our message is: `Greeting`
  * contains: `first_name`, `last_name` string field
  * will take: a `GreetRequest` that contains a `Greeting`
  * will return: a `GreetResponse` that contains a `result` string

```proto
syntax = "proto3";

package greet;
option go_package="greetpb";

message Greeting {
  string first_name = 1;
  string last_name = 2;
}

message GreetRequest {
  Greeting greeting = 1;
}

message GreetResponse {
  string result = 1;
}

service GreetService {
  // Unary
  rpc Greet(GreetRequest) returns (GreetResponse) {};
}
```

---

## 20. Unary API Server Implementation

* hands-on:
* implement a Unary Greet RPC
* hook our new `GreetService` to the Server
* then, run the Server

In the newly autogenerated code, `greet.pb.go` we can find this code:

```go
// GreetServiceServer is the server API for GreetService service.
type GreetServiceServer interface {
  // Unary
  Greet(context.Context, *GreetRequest) (*GreetResponse, error)
}
```

and let's use this code with our `greet_server/server.go` file:

* implement the `type server struct` with this code:

```go
type server struct{}

func (*server) Greet(ctx context.Context, req *greetpb.GreetRequest) (*greetpb.GreetResponse, error) {
  firstName := req.GetGreeting().GetFirstName()
  result := "Hello " + firstName
  res := &greetpb.GreetResponse{
    Result: result,
  }
  return res, nil
}
```

---

## 21. Unary API Client Implementation

* Hands-on:
* implement a client call for our Unary RPC
* test it against our server that is running!

first, add a simple logger in the `greet_server/server.go`

```go
func (*server) Greet(ctx context.Context, req *greetpb.GreetRequest) (*greetpb.GreetResponse, error) {
  fmt.Printf("Greet function was invoked with %v\n", req)
  ...
}
```

and let's improve `greet_client/client.go`:

```go
package main

import (
  "context"
  "fmt"
  "log"

  "../greetpb"
  "google.golang.org/grpc"
)

func main() {
  fmt.Println("Hello, I am a client.")

  cc, err := grpc.Dial("localhost:50051", grpc.WithInsecure()) // WithInsecure() for just now testing
  if err != nil {
    log.Fatalf("Could not connect: %v", err)
  }

  defer cc.Close()

  c := greetpb.NewGreetServiceClient(cc)
  // fmt.Printf("Created client: %f", c)

  doUnary(c)
}

func doUnary(c greetpb.GreetServiceClient) {
  fmt.Println("Starting to do a Unary RPC...")
  req := &greetpb.GreetRequest{
    Greeting: &greetpb.Greeting{
      FirstName: "Mark",
      LastName:  "Hahn",
    },
  }
  res, err := c.Greet(context.Background(), req)
  if err != nil {
    log.Fatalf("error while calling Greet RPC: %v", err)
  }
  log.Printf("Response from Greet: %v", res.Result)
}
```

and currently, server looks like this:

```go
package main

import (
  "context"
  "fmt"
  "log"
  "net"

  "../greetpb"

  "google.golang.org/grpc"
)

type server struct{}

func (*server) Greet(ctx context.Context, req *greetpb.GreetRequest) (*greetpb.GreetResponse, error) {
  fmt.Printf("Greet function was invoked with %v\n", req)
  firstName := req.GetGreeting().GetFirstName()
  result := "Hello " + firstName
  res := &greetpb.GreetResponse{
    Result: result,
  }
  return res, nil
}

func main() {
  fmt.Println("Hello world!")

  lis, err := net.Listen("tcp", "0.0.0.0:50051") // 50051 is a default port for gRPC
  if err != nil {
    log.Fatalf("Failed to listen: %v", err)
  }

  s := grpc.NewServer()
  greetpb.RegisterGreetServiceServer(s, &server{})

  if err := s.Serve(lis); err != nil {
    log.Fatalf("Failed to serve: %v", err)
  }
}
```

open your terminal and run the Server, you will see this:

```bash
$ go run greet/greet_server/server.go
Hello world!
```

and also open another terminal and run your client code:

```bash
go run greet/greet_client/client.go
Hello, I am a client.
Starting to do a Unary RPC...
2019/08/18 22:11:51 Response from Greet: Hello Mark
```

and your first terminal, running the server code show this info:

```bash
Greet function was invoked with greeting:<first_name:"Mark" last_name:"Hahn" >
```

---

## 22. [Exercise] Sum API

---

## 23. [Solution] Sum API

---

