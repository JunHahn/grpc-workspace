# Session 05: [Hands-On] gRPC Project Overview & Setup

---

## 18. What's an Unary API

* Unary RPC calls are basic Request / Response that everyone is familar with
* The client will send **one** message to the server and will receive **one** response from the server
* Unary RPC calls will be the most common for your APIs
  * Unary calls are very well suited when your data is small
  * Start with Unary when writing APIs and use streaming API if performance is an issue

```note
              Unary API
************                               ************
*          * -------> req ---------------> *          *
*  client  *                               *  server  *
*          * <------- resp <-------------- *          *
************                               ************
```

* In gRPC, Unary Calls are defined using Protocol Buffers
* For each RPC call, we have to define a "Request" message and a "Response" message

```proto
message GreetRequest {
  Greeting greeting = 1;
}

message GreetResponse {
  string result = 1;
}

service GreetService {
  // Unary
  rpc Greet(GreetRequest) returns (GreetResponse) {};
}
```

---

## 19. Greet API Definition

### 19.1 Hands On - Greet API Definition

* **Hands On**: define a Unary "Greet" API
* our message is: `Greeting`
  * contains: `first_name`, `last_name` string field
  * will take: a `GreetRequest` that contains a `Greeting`
  * will return: a `GreetResponse` that contains a `result` string

```proto
syntax = "proto3";

package greet;
option go_package="greetpb";

message Greeting {
  string first_name = 1;
  string last_name = 2;
}

message GreetRequest {
  Greeting greeting = 1;
}

message GreetResponse {
  string result = 1;
}

service GreetService {
  // Unary
  rpc Greet(GreetRequest) returns (GreetResponse) {};
}
```

---

## 20. Unary API Server Implementation

* hands-on:
* implement a Unary Greet RPC
* hook our new `GreetService` to the Server
* then, run the Server

In the newly autogenerated code, `greet.pb.go` we can find this code:

```go
// GreetServiceServer is the server API for GreetService service.
type GreetServiceServer interface {
  // Unary
  Greet(context.Context, *GreetRequest) (*GreetResponse, error)
}
```

and let's use this code with our `greet_server/server.go` file:

* implement the `type server struct` with this code:

```go
type server struct{}

func (*server) Greet(ctx context.Context, req *greetpb.GreetRequest) (*greetpb.GreetResponse, error) {
  firstName := req.GetGreeting().GetFirstName()
  result := "Hello " + firstName
  res := &greetpb.GreetResponse{
    Result: result,
  }
  return res, nil
}
```

---

## 21. Unary API Client Implementation

* Hands-on:
* implement a client call for our Unary RPC
* test it against our server that is running!

first, add a simple logger in the `greet_server/server.go`

```go
func (*server) Greet(ctx context.Context, req *greetpb.GreetRequest) (*greetpb.GreetResponse, error) {
  fmt.Printf("Greet function was invoked with %v\n", req)
  ...
}
```

and let's improve `greet_client/client.go`:

```go
package main

import (
  "context"
  "fmt"
  "log"

  "../greetpb"
  "google.golang.org/grpc"
)

func main() {
  fmt.Println("Hello, I am a client.")

  cc, err := grpc.Dial("localhost:50051", grpc.WithInsecure()) // WithInsecure() for just now testing
  if err != nil {
    log.Fatalf("Could not connect: %v", err)
  }

  defer cc.Close()

  c := greetpb.NewGreetServiceClient(cc)
  // fmt.Printf("Created client: %f", c)

  doUnary(c)
}

func doUnary(c greetpb.GreetServiceClient) {
  fmt.Println("Starting to do a Unary RPC...")
  req := &greetpb.GreetRequest{
    Greeting: &greetpb.Greeting{
      FirstName: "Mark",
      LastName:  "Hahn",
    },
  }
  res, err := c.Greet(context.Background(), req)
  if err != nil {
    log.Fatalf("error while calling Greet RPC: %v", err)
  }
  log.Printf("Response from Greet: %v", res.Result)
}
```

and currently, server looks like this:

```go
package main

import (
  "context"
  "fmt"
  "log"
  "net"

  "../greetpb"

  "google.golang.org/grpc"
)

type server struct{}

func (*server) Greet(ctx context.Context, req *greetpb.GreetRequest) (*greetpb.GreetResponse, error) {
  fmt.Printf("Greet function was invoked with %v\n", req)
  firstName := req.GetGreeting().GetFirstName()
  result := "Hello " + firstName
  res := &greetpb.GreetResponse{
    Result: result,
  }
  return res, nil
}

func main() {
  fmt.Println("Hello world!")

  lis, err := net.Listen("tcp", "0.0.0.0:50051") // 50051 is a default port for gRPC
  if err != nil {
    log.Fatalf("Failed to listen: %v", err)
  }

  s := grpc.NewServer()
  greetpb.RegisterGreetServiceServer(s, &server{})

  if err := s.Serve(lis); err != nil {
    log.Fatalf("Failed to serve: %v", err)
  }
}
```

open your terminal and run the Server, you will see this:

```bash
$ go run greet/greet_server/server.go
Hello world!
```

and also open another terminal and run your client code:

```bash
go run greet/greet_client/client.go
Hello, I am a client.
Starting to do a Unary RPC...
2019/08/18 22:11:51 Response from Greet: Hello Mark
```

and your first terminal, running the server code show this info:

```bash
Greet function was invoked with greeting:<first_name:"Mark" last_name:"Hahn" >
```

---

## 22. [Exercise] Sum API

* implement a Sum RPC Unary API in a `CalculatorService`:
  * the function takes a `Request` message that has two intergers,
  * and returns a `Response` that represents the sum of them
    * remember to first implement the service definition in a `.proto` file, alongside the RPC message
    * implement the Server code first
    * test the Server code by implementing the Client

* Example:
  * the Client will send two numbers (`3` and `10`) and the Server will response with (`13`)

---

## 23. [Solution] Sum API

* create this directory and files:
  * `calculator`
    * `calculator_client`
      * `client.go`
    * `calculator_server`
      * `server.go`
    * `calculatorpb`
      * `calculator.proto`

let's define the `.proto` file first:

```proto
syntax = "proto3";

package calculator;
option go_package = "calculatorpb";

message SumRequest {
  int32 first_number = 1;
  int32 second_number = 2;
}

message SumResponse {
  int32 sum_result = 1;
}

service CalculatorService {
  rpc Sum(SumRequest) returns (SumResponse) {};
}
```

and generate code with this command:

```bash
protoc calculator/calculatorpb/calculator.proto --go_out=plugins=grpc:.
```

then, we get `calculator.pb.go` under `calculatorpb` directory which is also a directory that has `calculator.proto`.

Now, we can write the Server first:

```go
package main

import (
  "context"
  "fmt"
  "log"
  "net"

  "../calculatorpb"
  "google.golang.org/grpc"
)

type server struct{}

func (*server) Sum(ctx context.Context, req *calculatorpb.SumRequest) (*calculatorpb.SumResponse, error) {
  fmt.Printf("Received Sum RPC: %v", req)
  firstNumber := req.FirstNumber
  secondNumber := req.SecondNumber
  sum := firstNumber + secondNumber
  res := &calculatorpb.SumResponse{
    SumResult: sum,
  }
  return res, nil
}

func main() {
  fmt.Println("Calculator Server")

  lis, err := net.Listen("tcp", "0.0.0.0:50051")
  if err != nil {
    log.Fatalf("Failed to listen: %v", err)
  }

  s := grpc.NewServer()
  calculatorpb.RegisterCalculatorServiceServer(s, &server{})

  if err := s.Serve(lis); err != nil {
    log.Fatalf("Failed to server: %v", err)
  }
}
```

now we can test the server (and keep it open):

```bash
$ go run calculator/calculator_server/server.go
Calculator Server
```

And, let's write the client:

```go
package main

import (
  "context"
  "fmt"
  "log"

  "../calculatorpb"
  "google.golang.org/grpc"
)

func main() {
  fmt.Println("Calculator Client")
  cc, err := grpc.Dial("localhost:50051", grpc.WithInsecure())
  if err != nil {
    log.Fatalf("could not connnect: %v", err)
  }
  defer cc.Close()

  c := calculatorpb.NewCalculatorServiceClient(cc)
  // fmt.Printf("Created client: %f", c)

  doUnary(c)
}

func doUnary(c calculatorpb.CalculatorServiceClient) {
  fmt.Println("Starting to do a Sum Unary RPC...")
  req := &calculatorpb.SumRequest{
    FirstNumber:  5,
    SecondNumber: 40,
  }
  res, err := c.Sum(context.Background(), req)
  if err != nil {
    log.Fatalf("error whilst calling Sum RPC: %v", err)
  }
  log.Printf("Response from Sum: %v", res.SumResult)
}
```

and let's open another terminal and run the `client.go`:

```bash
$ go run calculator/calculator_client/client.go
Calculator Client
Starting to do a Sum Unary RPC...
2019/08/18 23:18:39 Response from Sum: 45
```

you can also see message from the other terminal running `server.go`

```bash
$ go run calculator/calculator_server/server.go
Calculator Server
Received Sum RPC: first_number:5 second_number:40
```

---
