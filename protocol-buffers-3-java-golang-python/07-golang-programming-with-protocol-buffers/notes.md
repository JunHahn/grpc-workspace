# Section 7. Golang Programming with Protocol Buffers

---

## 33. Setup & Code Download in Golang

### TODO: Setup your Mac

- Golang installed: https://golang.org/doc/install
- VSCode installed: https://code.visualstudio.com/
- The VSCode Golang extension: https://code.visualstudio.com/docs/languages/go
- The source code for this project (download / star the project): https://github.com/simplesteph/protobuf-example-go

- Golang packages:

```bash
go get -u github.com/golang/protobuf/protoc-gen-go
go get -u github.com/golang/protobuf/proto
```

- Protoc Compiler (see Setting up Protoc Compiler Section)

---

## 34. Code generation in Golang

### Hello World in golang

Check out your Mac has golang compliler

#### `main.go`

```go
package main

import (
  "fmt"
)

func main() {
  fmt.Println("Hello world!")
}
```

then run the code on your terminal:

```bash
go run main.go
```

If you can see and output: `Hello world!`, you are ready to go!

### `simple.proto` to `simple.pb.go`

When you are ready to run `*.go` file, let's try to add `*.proto` file.

Here is an example: `src/simple/simple.proto`

```proto
syntax = "proto3";

package example.simple;

message SimpleMessage {
  int32 id = 1;
  bool is_simple = 2;
  string name = 3;
  repeated int32 simple_list = 4;
}
```

Then we can generate `simple.pb.go` code from this `simple.proto` code.

Let's make a script, `generate.sh`, to generate the code

```sh
protoc -I src/ --go_out=src/ src/simple/simple.proto
```

cf) `protoc` is a compiler for protocol buffers.  

then you can generate code:

```bash
source generate.sh
```

or by running the command above.  

After running the script (or command), we get `simple.pb.go` under `src/simple` directory.

Here is the auto generated code:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: simple/simple.proto

package example_simple

import (
  fmt "fmt"
  math "math"

  proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SimpleMessage struct {
  Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
  IsSimple             bool     `protobuf:"varint,2,opt,name=is_simple,json=isSimple,proto3" json:"is_simple,omitempty"`
  Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
  SimpleList           []int32  `protobuf:"varint,4,rep,packed,name=simple_list,json=simpleList,proto3" json:"simple_list,omitempty"`
  XXX_NoUnkeyedLiteral struct{} `json:"-"`
  XXX_unrecognized     []byte   `json:"-"`
  XXX_sizecache        int32    `json:"-"`
}

func (m *SimpleMessage) Reset()         { *m = SimpleMessage{} }
func (m *SimpleMessage) String() string { return proto.CompactTextString(m) }
func (*SimpleMessage) ProtoMessage()    {}
func (*SimpleMessage) Descriptor() ([]byte, []int) {
  return fileDescriptor_9b3c868e94d57426, []int{0}
}

func (m *SimpleMessage) XXX_Unmarshal(b []byte) error {
  return xxx_messageInfo_SimpleMessage.Unmarshal(m, b)
}
func (m *SimpleMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
  return xxx_messageInfo_SimpleMessage.Marshal(b, m, deterministic)
}
func (m *SimpleMessage) XXX_Merge(src proto.Message) {
  xxx_messageInfo_SimpleMessage.Merge(m, src)
}
func (m *SimpleMessage) XXX_Size() int {
  return xxx_messageInfo_SimpleMessage.Size(m)
}
func (m *SimpleMessage) XXX_DiscardUnknown() {
  xxx_messageInfo_SimpleMessage.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleMessage proto.InternalMessageInfo

func (m *SimpleMessage) GetId() int32 {
  if m != nil {
    return m.Id
  }
  return 0
}

func (m *SimpleMessage) GetIsSimple() bool {
  if m != nil {
    return m.IsSimple
  }
  return false
}

func (m *SimpleMessage) GetName() string {
  if m != nil {
    return m.Name
  }
  return ""
}

func (m *SimpleMessage) GetSimpleList() []int32 {
  if m != nil {
    return m.SimpleList
  }
  return nil
}

func init() {
  proto.RegisterType((*SimpleMessage)(nil), "example.simple.SimpleMessage")
}

func init() { proto.RegisterFile("simple/simple.proto", fileDescriptor_9b3c868e94d57426) }

var fileDescriptor_9b3c868e94d57426 = []byte{
  // 147 bytes of a gzipped FileDescriptorProto
  0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x2e, 0xce, 0xcc, 0x2d,
  0xc8, 0x49, 0xd5, 0x87, 0x50, 0x7a, 0x05, 0x45, 0xf9, 0x25, 0xf9, 0x42, 0x7c, 0xa9, 0x15, 0x89,
  0x60, 0x2e, 0x44, 0x54, 0xa9, 0x90, 0x8b, 0x37, 0x18, 0xcc, 0xf2, 0x4d, 0x2d, 0x2e, 0x4e, 0x4c,
  0x4f, 0x15, 0xe2, 0xe3, 0x62, 0xca, 0x4c, 0x91, 0x60, 0x54, 0x60, 0xd4, 0x60, 0x0d, 0x62, 0xca,
  0x4c, 0x11, 0x92, 0xe6, 0xe2, 0xcc, 0x2c, 0x8e, 0x87, 0xa8, 0x96, 0x60, 0x52, 0x60, 0xd4, 0xe0,
  0x08, 0xe2, 0xc8, 0x2c, 0x86, 0xe8, 0x11, 0x12, 0xe2, 0x62, 0xc9, 0x4b, 0xcc, 0x4d, 0x95, 0x60,
  0x56, 0x60, 0xd4, 0xe0, 0x0c, 0x02, 0xb3, 0x85, 0xe4, 0xb9, 0xb8, 0x21, 0xaa, 0xe3, 0x73, 0x32,
  0x8b, 0x4b, 0x24, 0x58, 0x14, 0x98, 0x35, 0x58, 0x83, 0xb8, 0x20, 0x42, 0x3e, 0x99, 0xc5, 0x25,
  0x49, 0x6c, 0x60, 0x97, 0x18, 0x03, 0x02, 0x00, 0x00, 0xff, 0xff, 0x96, 0x04, 0x04, 0xce, 0xa0,
  0x00, 0x00, 0x00,
}
```

Please compare the `.proto` file and `.pb.go` file!

**PLEASE BE AWARE THAT WE SHOULD NOT EDIT THE GENERATED FILES**: The better practice is, when you want to update `.pb.go` file, then update your `.proto` file, and generate `.pb.go` file with `protoc`.

---

## 35. Simple Proto Struct in Golang

Now, we can add some code on the previous `main.go` file.

```go
package main

import (
  "fmt"

  example_simple "./src/simple"
)

func main() {
  doSimple()
}

func doSimple() {
  sm := example_simple.SimpleMessage{
    Id:         12345,
    IsSimple:   true,
    Name:       "My Simple Message",
    SimpleList: []int32{1, 4, 7, 8},
  }

  fmt.Println(sm)

  sm.Name = "I renamed you."
  fmt.Println(sm)

  fmt.Println("The ID is: ", sm.GetId())
  // fmt.Println("The ID is: ", sm.Id) // NOT RECOMMENDED!!!
}
```

---

## 36. `go_package` option

In `.proto` file, you can change behaviour of `protoc` compiler:

Let's look at our previous code: `simple.proto`

```proto
syntax = "proto3";

package example.simple;

message SimpleMessage {
  int32 id = 1;
  bool is_simple = 2;
  string name = 3;
  repeated int32 simple_list = 4;
}
```

Here we can add `option`:

```proto
syntax = "proto3";

package example.simple;

option go_package = "simplepb"

message SimpleMessage {
  int32 id = 1;
  bool is_simple = 2;
  string name = 3;
  repeated int32 simple_list = 4;
}
```

Now, we regenerate the code with `generate.sh`,  

the the package name in `simple.pb.go` has been changed from

```go
package example_simple
```

to  

```go
package simplepb
```

In addition, since the `simple.pb.go` file has been updated, we also need to revise some codes in `main.go`

the current `main.go` is:

```go
package main

import (
  "fmt"

  example_simple "./src/simple"
)

func main() {
  doSimple()
}

func doSimple() {
  sm := example_simple.SimpleMessage{
    Id:         12345,
    IsSimple:   true,
    Name:       "My Simple Message",
    SimpleList: []int32{1, 4, 7, 8},
  }

  fmt.Println(sm)

  sm.Name = "I renamed you."
  fmt.Println(sm)

  fmt.Println("The ID is: ", sm.GetId())
  // fmt.Println("The ID is: ", sm.Id) // NOT RECOMMENDED!!!
}
```

and after fix, the code would be:

```go
package main

import (
  "fmt"

  simplepb "./src/simple"
)

func main() {
  doSimple()
}

func doSimple() {
  sm := simplepb.SimpleMessage{
    Id:         12345,
    IsSimple:   true,
    Name:       "My Simple Message",
    SimpleList: []int32{1, 4, 7, 8},
  }

  fmt.Println(sm)

  sm.Name = "I renamed you."
  fmt.Println(sm)

  fmt.Println("The ID is: ", sm.GetId())
  // fmt.Println("The ID is: ", sm.Id) // NOT RECOMMENDED!!!
}
```

the `option` keyword is very useful, **Uber** uses it as standard, so it's better to keep on all our protobuf files because that makes easier to read codes.

---

## 37. Reading and Writing to Disk

Let's think about how to read and write to our disk.  

the code below is updaetd for writing and reading data to our disk:  

```go
package main

import (
  "fmt"
  "io/ioutil"
  "log"

  simplepb "./src/simple"
  "github.com/gogo/protobuf/proto"
)

func main() {
  sm := doSimple()

  readAndWriteDemo(sm)
}

func readAndWriteDemo(sm proto.Message) {
  writeToFile("simple.bin", sm)
  sm2 := &simplepb.SimpleMessage{}
  readFromFile("simple.bin", sm2)
  fmt.Println("Read the content:", sm2)
}

func writeToFile(fname string, pb proto.Message) error {
  out, err := proto.Marshal(pb)
  if err != nil {
    log.Fatalln("Can't serialise to bytes", err)
    return err
  }

  if err := ioutil.WriteFile(fname, out, 0644); err != nil {
    log.Fatalln("Can't write to file", err)
    return err
}

  fmt.Println("Data has been written!")
  return nil
}

func readFromFile(fname string, pb proto.Message) error {
  in, err := ioutil.ReadFile(fname)

  if err != nil {
    log.Fatalln("Something went wrong when reading the file", err)
    return err
  }

  err2 := proto.Unmarshal(in, pb)
  if err2 != nil {
    log.Fatalln("Couldn't put the bytes into the protocol buffers struct", err)
    return err2
  }

  return nil
}

func doSimple() *simplepb.SimpleMessage {
  sm := simplepb.SimpleMessage{
    Id:         12345,
    IsSimple:   true,
    Name:       "My Simple Message",
    SimpleList: []int32{1, 4, 7, 8},
  }

  fmt.Println(sm)

  sm.Name = "I renamed you."
  fmt.Println(sm)

  fmt.Println("The ID is: ", sm.GetId())

  return &sm
}
```

---

## 38. Reading and Writing to JSON

We add function that can make `main.go` read and write to JSON.

add these code to the previous example:

```go
func toJSON(pb proto.Message) string {
  marshaler := jsonpb.Marshaler{}
  out, err := marshaler.MarshalToString(pb)
  if (err != nil) {
    log.Fatalln("Can't convert to JSON", err)
    return ""
  }
  return out
}
```

this will add `"github.com/golang/protobuf/jsonpb"`.

then add these code to main:  

```go
smAsString := toJSON(sm)
fmt.Println(smAsString)
```

Let's add read from JSON feature by creading another `func fromJSON(string, proto.Message)`:

```go
func fromJSON(in string, pb proto.Message) {
  err := jsonpb.UnmarshalString(in, pb)
  if err != nil {
    log.Fatalln("Couldn't unmarshal the JSON into the pb struct", err)
  }
}
```

and add additional code to your `func main()`:

your current `func main()` looks like this:

```go
func main() {
  sm := doSimple()

  readAndWriteDemo(sm)
  smAsString := toJSON(sm)
  fmt.Println(smAsString)
}
```

and append these three lines:

```go
sm2 := &simplepb.SimpleMessage{}
fromJSON(smAsString, sm2)
fmt.Println("Successfully created proto struct:", sm2)
```

then take them into another function, `func jsonDemo()`:

```go
func jsonDemo(sm proto.Message) {
  smAsString := toJSON(sm)
  fmt.Println(smAsString)

  sm2 := &simplepb.SimpleMessage{}
  fromJSON(smAsString, sm2)
  fmt.Println("Successfully created proto struct:", sm2)
}
```

result: `main.go`

```go
package main

import (
  "fmt"
  "io/ioutil"
  "log"

  simplepb "./src/simple"
  "github.com/golang/protobuf/jsonpb"
  "github.com/golang/protobuf/proto"
)

func main() {
  sm := doSimple()

  // readAndWriteDemo(sm)
  jsonDemo(sm)
}

func toJSON(pb proto.Message) string {
  marshaler := jsonpb.Marshaler{}
  out, err := marshaler.MarshalToString(pb)
  if (err != nil) {
    log.Fatalln("Can't convert to JSON", err)
    return ""
  }
  return out
}

func jsonDemo(sm proto.Message) {
  smAsString := toJSON(sm)
  fmt.Println(smAsString)

  sm2 := &simplepb.SimpleMessage{}
  fromJSON(smAsString, sm2)
  fmt.Println("Successfully created proto struct:", sm2)
}

func fromJSON(in string, pb proto.Message) {
  err := jsonpb.UnmarshalString(in, pb)
  if err != nil {
    log.Fatalln("Couldn't unmarshal the JSON into the pb struct", err)
  }
}

func readAndWriteDemo(sm proto.Message) {
  writeToFile("simple.bin", sm)
  sm2 := &simplepb.SimpleMessage{}
  readFromFile("simple.bin", sm2)
  fmt.Println("Read the content:", sm2)
}

func writeToFile(fname string, pb proto.Message) error {
  out, err := proto.Marshal(pb)
  if err != nil {
    log.Fatalln("Can't serialise to bytes", err)
    return err
  }

  if err := ioutil.WriteFile(fname, out, 0644); err != nil {
    log.Fatalln("Can't write to file", err)
    return err
}

  fmt.Println("Data has been written!")
  return nil
}

func readFromFile(fname string, pb proto.Message) error {
  in, err := ioutil.ReadFile(fname)

  if err != nil {
    log.Fatalln("Something went wrong when reading the file", err)
    return err
  }

  err2 := proto.Unmarshal(in, pb)
  if err2 != nil {
    log.Fatalln("Couldn't put the bytes into the protocol buffers struct", err)
    return err2
  }

  return nil
}

func doSimple() *simplepb.SimpleMessage {
  sm := simplepb.SimpleMessage{
    Id:         12345,
    IsSimple:   true,
    Name:       "My Simple Message",
    SimpleList: []int32{1, 4, 7, 8},
  }

  fmt.Println(sm)

  sm.Name = "I renamed you."
  fmt.Println(sm)

  fmt.Println("The ID is: ", sm.GetId())

  return &sm
}
```

- The reason why we do protobuf to JSON:
  - debugging
  - when you want to analyse contents
  - JSON is weaker format than protobuf messages

---

## 39, Enum Proto Struct in Golang

create another directory called `enum_example` under the `src` directory, and add `enum_example.proto` under the directory:

```structure
src/
  enum_example/
    enum_example.proto
  simple/
    simple.pb.go
    simple.proto
main.go
generate.sh
```

the `enum_example.proto` looks like this:

```proto
syntax = "proto3";

package example.enumerations;

option go_package = "enumpb";

message EnumMessage {
  int32 id = 1;
  DayOfTheWeek day_of_the_week = 2;
}

enum DayOfTheWeek {
  UNKNOWN = 0;
  MONDAY = 1;
  TUESDAY = 2;
  WEDNESDAY = 3;
  THURSDAY = 4;
  FRIDAY = 5;
  SATURDAY = 6;
  SUNDAY = 7;
}
```

Do NOT forget to add `option go_package = "packagepb";` to your `.proto` files!!!  

Then you can generate code with this command:

```bash
protoc -I src/ --go_out=src/ src/enum_example/enum_example.proto
```

and add this command to `generate.sh` and run it:

```bash
source generate.sh
```

and you get `src/enum_example/enum_example.pb.go`

Here is the actual code:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: enum_example/enum_example.proto

package enumpb

import (
  fmt "fmt"
  proto "github.com/golang/protobuf/proto"
  math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DayOfTheWeek int32

const (
  DayOfTheWeek_UNKNOWN   DayOfTheWeek = 0
  DayOfTheWeek_MONDAY    DayOfTheWeek = 1
  DayOfTheWeek_TUESDAY   DayOfTheWeek = 2
  DayOfTheWeek_WEDNESDAY DayOfTheWeek = 3
  DayOfTheWeek_THURSDAY  DayOfTheWeek = 4
  DayOfTheWeek_FRIDAY    DayOfTheWeek = 5
  DayOfTheWeek_SATURDAY  DayOfTheWeek = 6
  DayOfTheWeek_SUNDAY    DayOfTheWeek = 7
)

var DayOfTheWeek_name = map[int32]string{
  0: "UNKNOWN",
  1: "MONDAY",
  2: "TUESDAY",
  3: "WEDNESDAY",
  4: "THURSDAY",
  5: "FRIDAY",
  6: "SATURDAY",
  7: "SUNDAY",
}

var DayOfTheWeek_value = map[string]int32{
  "UNKNOWN":   0,
  "MONDAY":    1,
  "TUESDAY":   2,
  "WEDNESDAY": 3,
  "THURSDAY":  4,
  "FRIDAY":    5,
  "SATURDAY":  6,
  "SUNDAY":    7,
}

func (x DayOfTheWeek) String() string {
  return proto.EnumName(DayOfTheWeek_name, int32(x))
}

func (DayOfTheWeek) EnumDescriptor() ([]byte, []int) {
  return fileDescriptor_8293647c26efc6c4, []int{0}
}

type EnumMessage struct {
  Id                   int32        `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
  DayOfTheWeek         DayOfTheWeek `protobuf:"varint,2,opt,name=day_of_the_week,json=dayOfTheWeek,proto3,enum=example.enumerations.DayOfTheWeek" json:"day_of_the_week,omitempty"`
  XXX_NoUnkeyedLiteral struct{}     `json:"-"`
  XXX_unrecognized     []byte       `json:"-"`
  XXX_sizecache        int32        `json:"-"`
}

func (m *EnumMessage) Reset()         { *m = EnumMessage{} }
func (m *EnumMessage) String() string { return proto.CompactTextString(m) }
func (*EnumMessage) ProtoMessage()    {}
func (*EnumMessage) Descriptor() ([]byte, []int) {
  return fileDescriptor_8293647c26efc6c4, []int{0}
}

func (m *EnumMessage) XXX_Unmarshal(b []byte) error {
  return xxx_messageInfo_EnumMessage.Unmarshal(m, b)
}
func (m *EnumMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
  return xxx_messageInfo_EnumMessage.Marshal(b, m, deterministic)
}
func (m *EnumMessage) XXX_Merge(src proto.Message) {
  xxx_messageInfo_EnumMessage.Merge(m, src)
}
func (m *EnumMessage) XXX_Size() int {
  return xxx_messageInfo_EnumMessage.Size(m)
}
func (m *EnumMessage) XXX_DiscardUnknown() {
  xxx_messageInfo_EnumMessage.DiscardUnknown(m)
}

var xxx_messageInfo_EnumMessage proto.InternalMessageInfo

func (m *EnumMessage) GetId() int32 {
  if m != nil {
    return m.Id
  }
  return 0
}

func (m *EnumMessage) GetDayOfTheWeek() DayOfTheWeek {
  if m != nil {
    return m.DayOfTheWeek
  }
    return DayOfTheWeek_UNKNOWN
}

func init() {
  proto.RegisterEnum("example.enumerations.DayOfTheWeek", DayOfTheWeek_name, DayOfTheWeek_value)
  proto.RegisterType((*EnumMessage)(nil), "example.enumerations.EnumMessage")
}

func init() { proto.RegisterFile("enum_example/enum_example.proto", fileDescriptor_8293647c26efc6c4) }

var fileDescriptor_8293647c26efc6c4 = []byte{
  // 239 bytes of a gzipped FileDescriptorProto
  0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0x4f, 0xcd, 0x2b, 0xcd,
  0x8d, 0x4f, 0xad, 0x48, 0xcc, 0x2d, 0xc8, 0x49, 0xd5, 0x47, 0xe6, 0xe8, 0x15, 0x14, 0xe5, 0x97,
  0xe4, 0x0b, 0x89, 0xc0, 0xb8, 0x20, 0xb9, 0xd4, 0xa2, 0xc4, 0x92, 0xcc, 0xfc, 0xbc, 0x62, 0xa5,
  0x0c, 0x2e, 0x6e, 0xd7, 0xbc, 0xd2, 0x5c, 0xdf, 0xd4, 0xe2, 0xe2, 0xc4, 0xf4, 0x54, 0x21, 0x3e,
  0x2e, 0xa6, 0xcc, 0x14, 0x09, 0x46, 0x05, 0x46, 0x0d, 0xd6, 0x20, 0xa6, 0xcc, 0x14, 0x21, 0x4f,
  0x2e, 0xfe, 0x94, 0xc4, 0xca, 0xf8, 0xfc, 0xb4, 0xf8, 0x92, 0x8c, 0xd4, 0xf8, 0xf2, 0xd4, 0xd4,
  0x6c, 0x09, 0x26, 0x05, 0x46, 0x0d, 0x3e, 0x23, 0x25, 0x3d, 0x6c, 0xc6, 0xe9, 0xb9, 0x24, 0x56,
  0xfa, 0xa7, 0x85, 0x64, 0xa4, 0x86, 0xa7, 0xa6, 0x66, 0x07, 0xf1, 0xa4, 0x20, 0xf1, 0xb4, 0xca,
  0xb9, 0x78, 0x90, 0x65, 0x85, 0xb8, 0xb9, 0xd8, 0x43, 0xfd, 0xbc, 0xfd, 0xfc, 0xc3, 0xfd, 0x04,
  0x18, 0x84, 0xb8, 0xb8, 0xd8, 0x7c, 0xfd, 0xfd, 0x5c, 0x1c, 0x23, 0x05, 0x18, 0x41, 0x12, 0x21,
  0xa1, 0xae, 0xc1, 0x20, 0x0e, 0x93, 0x10, 0x2f, 0x17, 0x67, 0xb8, 0xab, 0x8b, 0x1f, 0x84, 0xcb,
  0x2c, 0xc4, 0xc3, 0xc5, 0x11, 0xe2, 0x11, 0x1a, 0x04, 0xe6, 0xb1, 0x80, 0x74, 0xb9, 0x05, 0x79,
  0x82, 0xd8, 0xac, 0x20, 0x99, 0x60, 0xc7, 0x90, 0xd0, 0x20, 0x10, 0x8f, 0x0d, 0x24, 0x13, 0x1c,
  0x0a, 0x36, 0x8f, 0xdd, 0x89, 0x23, 0x8a, 0x0d, 0xe4, 0xc6, 0x82, 0xa4, 0x24, 0x36, 0x70, 0x48,
  0x18, 0x03, 0x02, 0x00, 0x00, 0xff, 0xff, 0x32, 0x5e, 0x13, 0x6a, 0x2c, 0x01, 0x00, 0x00,
}
```

Then we want to update `main.go`. Here is the current code:

```go
package main

import (
  "fmt"
  "io/ioutil"
  "log"

  simplepb "./src/simple"
  "github.com/golang/protobuf/jsonpb"
  "github.com/golang/protobuf/proto"
)

func main() {
  sm := doSimple()

  readAndWriteDemo(sm)
  jsonDemo(sm)
}

func toJSON(pb proto.Message) string {
  marshaler := jsonpb.Marshaler{}
  out, err := marshaler.MarshalToString(pb)
  if err != nil {
    log.Fatalln("Can't convert to JSON", err)
    return ""
  }
  return out
}

func jsonDemo(sm proto.Message) {
  smAsString := toJSON(sm)
  fmt.Println(smAsString)

  sm2 := &simplepb.SimpleMessage{}
  fromJSON(smAsString, sm2)
  fmt.Println("Successfully created proto struct:", sm2)
}

func fromJSON(in string, pb proto.Message) {
  err := jsonpb.UnmarshalString(in, pb)
  if err != nil {
    log.Fatalln("Couldn't unmarshal the JSON into the pb struct", err)
  }
}

func readAndWriteDemo(sm proto.Message) {
  writeToFile("simple.bin", sm)
  sm2 := &simplepb.SimpleMessage{}
  readFromFile("simple.bin", sm2)
  fmt.Println("Read the content:", sm2)
}

func writeToFile(fname string, pb proto.Message) error {
  out, err := proto.Marshal(pb)
  if err != nil {
    log.Fatalln("Can't serialise to bytes", err)
    return err
  }

  if err := ioutil.WriteFile(fname, out, 0644); err != nil {
    log.Fatalln("Can't write to file", err)
    return err
  }

  fmt.Println("Data has been written!")
  return nil
}

func readFromFile(fname string, pb proto.Message) error {
  in, err := ioutil.ReadFile(fname)

  if err != nil {
    log.Fatalln("Something went wrong when reading the file", err)
    return err
  }

  err2 := proto.Unmarshal(in, pb)
  if err2 != nil {
    log.Fatalln("Couldn't put the bytes into the protocol buffers struct", err)
    return err2
  }

  return nil
}

func doSimple() *simplepb.SimpleMessage {
  sm := simplepb.SimpleMessage{
    Id:         12345,
    IsSimple:   true,
    Name:       "My Simple Message",
    SimpleList: []int32{1, 4, 7, 8},
  }

  fmt.Println(sm)

  sm.Name = "I renamed you."
  fmt.Println(sm)

  fmt.Println("The ID is: ", sm.GetId())

  return &sm
}
```

On the previous code, we want to add `doEnum()` in to the `func main()` and also define `func doEnum()` outside of the `func main`.

```go
func doEnum() {
  em := enumpb.EnumMessage{
    Id: 42,
    DayOfTheWeek: enumpb.DayOfTheWeek_THURSDAY,
  }

  em.DayOfTheWeek = enumpb.DayOfTheWeek_MONDAY
  fmt.Println(em)
}
```

In addition, do not forget to add import path for the new proto file: `enumpb "./src/enum_example"`.

We can run the `main.go`:

```bash
go run main.go
```

and get this output:

```bash
{12345 true My Simple Message [1 4 7 8] {} [] 0}
{12345 true I renamed you. [1 4 7 8] {} [] 0}
The ID is:  12345
Data has been written!
Read the content: id:12345 is_simple:true name:"I renamed you." simple_list:1 simple_list:4 simple_list:7 simple_list:8 
{"id":12345,"isSimple":true,"name":"I renamed you.","simpleList":[1,4,7,8]}
Successfully created proto struct: id:12345 is_simple:true name:"I renamed you." simple_list:1 simple_list:4 simple_list:7 simple_list:8 
{42 MONDAY {} [] 0}
```

FYI, the new `main.go` looks like this:

```go
package main

import (
  "fmt"
  "io/ioutil"
  "log"

  enumpb "./src/enum_example"
  simplepb "./src/simple"
  "github.com/golang/protobuf/jsonpb"
  "github.com/golang/protobuf/proto"
)

func main() {
  sm := doSimple()

  readAndWriteDemo(sm)
  jsonDemo(sm)

  doEnum()
}

func doEnum() {
  em := enumpb.EnumMessage{
    Id:           42,
    DayOfTheWeek: enumpb.DayOfTheWeek_THURSDAY,
  }

  em.DayOfTheWeek = enumpb.DayOfTheWeek_MONDAY
  fmt.Println(em)
}

func toJSON(pb proto.Message) string {
  marshaler := jsonpb.Marshaler{}
  out, err := marshaler.MarshalToString(pb)
  if err != nil {
    log.Fatalln("Can't convert to JSON", err)
    return ""
  }
  return out
}

func jsonDemo(sm proto.Message) {
  smAsString := toJSON(sm)
  fmt.Println(smAsString)

  sm2 := &simplepb.SimpleMessage{}
  fromJSON(smAsString, sm2)
  fmt.Println("Successfully created proto struct:", sm2)
}

func fromJSON(in string, pb proto.Message) {
  err := jsonpb.UnmarshalString(in, pb)
  if err != nil {
    log.Fatalln("Couldn't unmarshal the JSON into the pb struct", err)
  }
}

func readAndWriteDemo(sm proto.Message) {
  writeToFile("simple.bin", sm)
  sm2 := &simplepb.SimpleMessage{}
  readFromFile("simple.bin", sm2)
  fmt.Println("Read the content:", sm2)
}

func writeToFile(fname string, pb proto.Message) error {
  out, err := proto.Marshal(pb)
  if err != nil {
    log.Fatalln("Can't serialise to bytes", err)
    return err
  }

  if err := ioutil.WriteFile(fname, out, 0644); err != nil {
    log.Fatalln("Can't write to file", err)
    return err
  }

  fmt.Println("Data has been written!")
  return nil
}

func readFromFile(fname string, pb proto.Message) error {
  in, err := ioutil.ReadFile(fname)

  if err != nil {
    log.Fatalln("Something went wrong when reading the file", err)
    return err
  }

  err2 := proto.Unmarshal(in, pb)
  if err2 != nil {
    log.Fatalln("Couldn't put the bytes into the protocol buffers struct", err)
    return err2
  }

  return nil
}

func doSimple() *simplepb.SimpleMessage {
  sm := simplepb.SimpleMessage{
    Id:         12345,
    IsSimple:   true,
    Name:       "My Simple Message",
    SimpleList: []int32{1, 4, 7, 8},
  }

  fmt.Println(sm)

  sm.Name = "I renamed you."
  fmt.Println(sm)

  fmt.Println("The ID is: ", sm.GetId())

  return &sm
}
```

---

## 40. Complex Proto Struct in Golang

Let's make another directory `src/complex` and create a file called, `complex.proto` under the directory:

```proto
syntax = "proto3";

package example.complex;

option go_package = "complexpb";

message ComplexMessage {
  DummyMessage one_dummy = 2;
  repeated DummyMessage multiple_dummy = 3;
}

message DummyMessage {
  int32 id = 1;
  string name = 2;
}
```

and add this command:

```bash
protoc -I src/ --go_out=src/ src/complex/complex.proto
```

to `generate.sh`

and you can get this file, `complex.pb.go` under `src/complex` directory.

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: complex/complex.proto

package complexpb

import (
  fmt "fmt"
  proto "github.com/golang/protobuf/proto"
  math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ComplexMessage struct {
  OneDummy             *DummyMessage   `protobuf:"bytes,2,opt,name=one_dummy,json=oneDummy,proto3" json:"one_dummy,omitempty"`
  MultipleDummy        []*DummyMessage `protobuf:"bytes,3,rep,name=multiple_dummy,json=multipleDummy,proto3" json:"multiple_dummy,omitempty"`
  XXX_NoUnkeyedLiteral struct{}        `json:"-"`
  XXX_unrecognized     []byte          `json:"-"`
  XXX_sizecache        int32           `json:"-"`
}

func (m *ComplexMessage) Reset()         { *m = ComplexMessage{} }
func (m *ComplexMessage) String() string { return proto.CompactTextString(m) }
func (*ComplexMessage) ProtoMessage()    {}
func (*ComplexMessage) Descriptor() ([]byte, []int) {
  return fileDescriptor_467978440e6d1735, []int{0}
}

func (m *ComplexMessage) XXX_Unmarshal(b []byte) error {
  return xxx_messageInfo_ComplexMessage.Unmarshal(m, b)
}
func (m *ComplexMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
  return xxx_messageInfo_ComplexMessage.Marshal(b, m, deterministic)
}
func (m *ComplexMessage) XXX_Merge(src proto.Message) {
  xxx_messageInfo_ComplexMessage.Merge(m, src)
}
func (m *ComplexMessage) XXX_Size() int {
  return xxx_messageInfo_ComplexMessage.Size(m)
}
func (m *ComplexMessage) XXX_DiscardUnknown() {
  xxx_messageInfo_ComplexMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ComplexMessage proto.InternalMessageInfo

func (m *ComplexMessage) GetOneDummy() *DummyMessage {
  if m != nil {
    return m.OneDummy
  }
  return nil
}

func (m *ComplexMessage) GetMultipleDummy() []*DummyMessage {
  if m != nil {
    return m.MultipleDummy
  }
  return nil
}

type DummyMessage struct {
  Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
  Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
  XXX_NoUnkeyedLiteral struct{} `json:"-"`
  XXX_unrecognized     []byte   `json:"-"`
  XXX_sizecache        int32    `json:"-"`
}

func (m *DummyMessage) Reset()         { *m = DummyMessage{} }
func (m *DummyMessage) String() string { return proto.CompactTextString(m) }
func (*DummyMessage) ProtoMessage()    {}
func (*DummyMessage) Descriptor() ([]byte, []int) {
  return fileDescriptor_467978440e6d1735, []int{1}
}

func (m *DummyMessage) XXX_Unmarshal(b []byte) error {
  return xxx_messageInfo_DummyMessage.Unmarshal(m, b)
}
func (m *DummyMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
  return xxx_messageInfo_DummyMessage.Marshal(b, m, deterministic)
}
func (m *DummyMessage) XXX_Merge(src proto.Message) {
  xxx_messageInfo_DummyMessage.Merge(m, src)
}
func (m *DummyMessage) XXX_Size() int {
  return xxx_messageInfo_DummyMessage.Size(m)
}
func (m *DummyMessage) XXX_DiscardUnknown() {
  xxx_messageInfo_DummyMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DummyMessage proto.InternalMessageInfo

func (m *DummyMessage) GetId() int32 {
  if m != nil {
    return m.Id
  }
  return 0
}

func (m *DummyMessage) GetName() string {
  if m != nil {
    return m.Name
  }
  return ""
}

func init() {
  proto.RegisterType((*ComplexMessage)(nil), "example.complex.ComplexMessage")
  proto.RegisterType((*DummyMessage)(nil), "example.complex.DummyMessage")
}

func init() { proto.RegisterFile("complex/complex.proto", fileDescriptor_467978440e6d1735) }

var fileDescriptor_467978440e6d1735 = []byte{
  // 176 bytes of a gzipped FileDescriptorProto
  0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x4d, 0xce, 0xcf, 0x2d,
  0xc8, 0x49, 0xad, 0xd0, 0x87, 0xd2, 0x7a, 0x05, 0x45, 0xf9, 0x25, 0xf9, 0x42, 0xfc, 0xa9, 0x15,
  0x89, 0x20, 0xbe, 0x1e, 0x54, 0x58, 0x69, 0x12, 0x23, 0x17, 0x9f, 0x33, 0x84, 0xed, 0x9b, 0x5a,
  0x5c, 0x9c, 0x98, 0x9e, 0x2a, 0x64, 0xc5, 0xc5, 0x99, 0x9f, 0x97, 0x1a, 0x9f, 0x52, 0x9a, 0x9b,
  0x5b, 0x29, 0xc1, 0xa4, 0xc0, 0xa8, 0xc1, 0x6d, 0x24, 0xab, 0x87, 0xa6, 0x4f, 0xcf, 0x05, 0x24,
  0x0b, 0xd5, 0x11, 0xc4, 0x91, 0x9f, 0x97, 0x0a, 0x16, 0x10, 0x72, 0xe1, 0xe2, 0xcb, 0x2d, 0xcd,
  0x29, 0xc9, 0x2c, 0xc8, 0x81, 0x19, 0xc0, 0xac, 0xc0, 0x4c, 0xd8, 0x00, 0x5e, 0x98, 0x26, 0xb0,
  0xa8, 0x92, 0x11, 0x17, 0x0f, 0xb2, 0xb4, 0x10, 0x1f, 0x17, 0x53, 0x66, 0x8a, 0x04, 0xa3, 0x02,
  0xa3, 0x06, 0x6b, 0x10, 0x53, 0x66, 0x8a, 0x90, 0x10, 0x17, 0x4b, 0x5e, 0x62, 0x6e, 0x2a, 0xd8,
  0x71, 0x9c, 0x41, 0x60, 0xb6, 0x13, 0x77, 0x14, 0x27, 0xd4, 0xe8, 0x82, 0xa4, 0x24, 0x36, 0xb0,
  0x6f, 0x8d, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0x2f, 0x59, 0x14, 0x8b, 0x06, 0x01, 0x00, 0x00,
}
```

Then, let's modify our `main.go`:

```go
package main

import (
  ...
  complexpb "./src/complex"
  ...
)

func main() {
  ...
  doComplex()
}

func doComplex() {
  cm := complexpb.ComplexMessage{
    OneDummy: &complexpb.DummyMessage{
      Id:   1,
      Name: "First message",
    },
    MultipleDummy: []*complexpb.DummyMessage{
      &complexpb.DummyMessage{
        Id:   2,
        Name: "Second message",
      },
      &complexpb.DummyMessage{
        Id:   3,
        Name: "Third message",
      },
    },
  }
  fmt.Println(cm)
}

...
```

and run this code:

```bash
go run main.go
```

You can see the end of output with this:

```bash
...
{id:1 name:"First message"  [id:2 name:"Second message"  id:3 name:"Third message" ] {} [] 0}
```

---

## 41. Practice Exercise Golang (self-guided)

Using this `.proto` definition: [link](https://github.com/protocolbuffers/protobuf/blob/master/examples/addressbook.proto)

```proto
// See README.txt for information and build instructions.
//
// Note: START and END tags are used in comments to define sections used in
// tutorials.  They are not part of the syntax for Protocol Buffers.
//
// To get an in-depth walkthrough of this file and the related examples, see:
// https://developers.google.com/protocol-buffers/docs/tutorials

// [START declaration]
syntax = "proto3";
package tutorial;

import "google/protobuf/timestamp.proto";
// [END declaration]

// [START java_declaration]
option java_package = "com.example.tutorial";
option java_outer_classname = "AddressBookProtos";
// [END java_declaration]

// [START csharp_declaration]
option csharp_namespace = "Google.Protobuf.Examples.AddressBook";
// [END csharp_declaration]

// [START messages]
message Person {
  string name = 1;
  int32 id = 2;  // Unique ID number for this person.
  string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    string number = 1;
    PhoneType type = 2;
  }

  repeated PhoneNumber phones = 4;

  google.protobuf.Timestamp last_updated = 5;
}

// Our address book file is just one of these.
message AddressBook {
  repeated Person people = 1;
}
// [END messages]
```

- implement a way to read and write `Person` in the `AddressBook` with our previous learnings.
- Solution will be here with some readings: [link](https://developers.google.com/protocol-buffers/docs/gotutorial)

---

## 42. `GoGo` Protobuf as an Alternative

### GoGo

- In the open source world, it is not unusual to see active community members fork a popular project and add features they find the community needs.
- One notable project is "gogo", created by Walter Schulze
  - aims to provide an alternative at how Protocol Buffers and gRPC are implemented in Go
  - This different implementation from the one provided by Google has many benefits, mainly around performance and usability, as well as providing more code generation options, which makes this project one of the most important in the protobuf & gRPC ecosystem today
  - You can find the project alongside its 1800+ stars on GitHub here: https://github.com/gogo/protobufAs per their project:

### gogoproto

- `gogoprotobuf` is a fork of golang/protobuf with extra code generation features.
- This code generation is used to achieve:
  - fast marshalling and unmarshalling
  - more canonical Go structures
  - goprotobuf compatibility
  - less typing by optionally generating extra helper code
  - peace of mind by optionally generating test and benchmark code
  - other serialization formats
  - There's a really nice article describing how to get started: https://jbrandhorst.com/post/gogoproto/

---
